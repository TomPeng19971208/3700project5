#!/usr/bin/env python

import sys, socket, select, time, json, random

#key-value pair
store = {}
#role can be one of "1.followilrer, 2.candidate, 3.leader"
role = 1
leader_id = 'FFFF'
#candidate timeout (1.5~3s)
candidate_timeout = random.randrange(150, 300)/100
#timeout of waiting for heartbeat from leader
leader_timeout = 0.25
#interval of sending heartbeat
heartbeat_interval = 0.1
# current term 
current_term = 0
#last action's time
last_action_time = time.time()
#whether self have voted in this term 
voted = False
vote_received = 1
recv_buffer = []

# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replicas = sys.argv[2:]

last_action_time=0

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)

def getVote():
    global current_term
    if leader_id == 'FFFF': 
       #broadcast get_vote message to all replicas
       msg = {'src': my_id, 'dst': 'FFFF', 'leader': 'FFFF', 'type': 'get_vote', 'term':current_term}
       sock.send(json.dumps(msg))
       #print '%s sending a get_vote to %s' % (msg['src'], msg['dst'])
       current_term += 1
    else:
        return
        
    #when broad cast, set dst to 'FFFF'
def send_msg(msg):
    if msg['dst']=='FFFF':
       for r in replicas:
           msg['dst']=r
           sock.send(json.dumps(msg))
    else:
       #print(msg)
       sock.send(json.dumps(msg))
 
def reset_timeouts():
    global last_action_time
    global candidate_timeout
    last_action_time = time.time()
    candidate_timeout = random.randrange(150, 300)/100

#execute all of the messages stored in the buffer
def clear_buffer():
    global recv_buffer
    #self is the leader
    if role==3:
        for msg in recv_buffer:
            handle_recv(msg)
        recv_buffer=[]
    else:
        for msg in recv_buffer:
            redirect = {"src": msg['dst'], "dst": msg['src'], "leader": leader_id, "type": "redirect", "MID": msg['MID']}
            send_msg(redirect)
        recv_buffer = []

def do_get(key, mid):
    if key in store.keys():
        return {'type': 'ok', 'MID': store[key]['MID'], 'value': store[key]['value']}
    else:
        return {'type': 'ok', 'value': '', 'MID': mid}
    
def do_put(key, value, mid):
    global store
    if role==3:
        store[key]={'value': value, 'MID': mid}
        return {'type': 'ok'}
    else:
        return {'type': 'redirect'}


def handle_get_put(msg):
    #print(msg)
    msg_type = msg['type']
    #self is the leader
    if role==3:
        if msg_type == 'get':
            resp = do_get(msg['key'], msg['MID'])
            resp['src']=my_id
            resp['dst']=msg['src']
            resp['leader']=leader_id
            send_msg(resp)
        if msg_type == 'put':
            resp = do_put(msg['key'], msg['value'], msg['MID'])
            resp['src']=my_id
            resp['dst']=msg['src']
            resp['leader']=leader_id
            resp['MID']=msg['MID']
            print(store)
            send_msg(resp)
    else:
        resp = msg
        resp['dst']=resp['src']
        resp['src']=my_id
        resp['type']='redirect'
        send_msg(resp)
    
    
def handle_recv(msg):
    global current_term
    global voted
    global last_action_time
    global vote_received
    global leader_id
    global role
    global store
    msg_type = msg['type']
    if msg_type == 'get' or msg_type=='put' and not leader_id == 'FFFF':
        handle_get_put(msg)
    elif msg_type == 'get_vote':
        if not voted and msg['term'] <= current_term:
            print("vote----------\n")
            resp = {'src': my_id, 'dst': msg['src'], 'type': 'send_vote', 'leader': 'FFFF'}
            send_msg(resp)
            voted = True
        #received hearbeat from leader
        if msg_type == 'noop' and not role==3:
            last_action_time = time.time()
        #received a vote from others
    elif msg_type == 'send_vote':
        print("receive vote------\n")
        if leader_id=='FFFF':
            vote_received += 1
            print(vote_received)
            #self becomes the leader
            if(vote_received >= 3):
                print("send announce leader------\n")
                leader_id = my_id
                role = 3
                send_msg({'src': my_id, 'dst': 'FFFF', 'leader': my_id, 'type': 'announce_leader', 'term': current_term, 'store': store})
                    
    elif msg_type == 'announce_leader' and leader_id=='FFFF':
        print("received announce_leader")
        current_term = msg['term']
        store = msg['store']
        vote_received = 1
        leader_id = msg['src']
        reset_timeouts()
        #clear_buffer()

while True:
    global time_passed
    global last_action_time
    global role
    global leader_id
    global vote
    global recv_buffer
    ready = select.select([sock], [], [], 0.1)[0]
    if sock in ready:
        msg_raw = sock.recv(32768)
        if len(msg_raw) == 0: continue
        msg = json.loads(msg_raw)
        #if leader is lost or has not been elected, add the msg to a buffer
        if leader_id=='FFFF':
            recv_buffer.append(msg)
        #else:
        #    clear_buffer()
        handle_recv(msg)
        #end of receiving msgs---------
        clock = time.time()
        time_passed = clock-last_action_time
        #send a heartbeat if self is the leader
        if time_passed > heartbeat_interval and role==3:
            print("send heartbeat------")
            print(my_id)
            msg = {'src': my_id, 'dst': 'FFFF', 'leader': 'FFFF', 'type': 'noop'}
            send_msg(msg)
            last_action_time = clock
            #become a candidate after candidate timeout
        elif time_passed > candidate_timeout and not role == 3 and leader_id=='FFFF':
            role = 2
            print("becoming leader")
            getVote()
            last_action_time = clock
            #remove leader if self has not received hearbeats from leader
        elif time_passed > leader_timeout and not role==3: 
            leader_id='FFFF'
            voted = False
            reset_timeouts()
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
