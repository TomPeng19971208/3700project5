#!/usr/bin/env python

import sys, socket, select, time, json, random

global store, role, leader_id, last_action_time, voted, vote_received, recv_buffer

#---------state machine persistent------
my_id = sys.argv[1]
replicas = sys.argv[2:]
#key-value pair
store = {}
recv_buffer = []

#{key:..., value:..., term:..., client: , MID: }
log_entry = []

#--------state machine volatile-----
next_index={}
match_index={}
commit_idx = -1
last_applied = -1

#--------constant---------
#candidate timeout (1.5~3s)
candidate_timeout = random.randrange(1500, 3000) / 10000.0000
#interval of sending heartbeat
heartbeat_interval = 0.1
#last action's time
last_action_time = time.time()



#--------election----------
#"1-follower, 2-candidate, 3-leader"
role = 1
voted = False
vote_received = 1
current_term = 0
leader_id = 'FFFF'

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)





def getVote():
    global current_term
    #print("get vote----------"+my_id)
    if leader_id == 'FFFF': 
       #broadcast get_vote message to all replicas
       current_term += 1
       voted = True
       msg = {'src': my_id, 'dst': 'FFFF', 'leader': 'FFFF', 'type': 'get_vote', 'term':current_term, 'leader': 'FFFF', 'lastLogIndex': len(log_entry)-1}
       sock.send(json.dumps(msg))
       #print '%s sending a get_vote to %s' % (msg['src'], msg['dst'])
       
    else:
        return
        
    #when broad cast, set dst to 'FFFF'
def send_msg(msg):
    if 'entries' in msg.keys():
       if len(msg['entries'])>50:
           return
    if msg['dst']=='FFFF':
       for r in replicas:
           msg['dst']=r
           sock.send(json.dumps(msg))
       #msg['dst']=my_id
       #sock.send(json.dumps(msg))
    else:
       sock.send(json.dumps(msg))
 
def reset_timeouts():
    global last_action_time
    global candidate_timeout
    last_action_time = time.time()
    candidate_timeout = random.randrange(1500, 3000) / 10000.0000

"""
#execute all of the messages stored in the buffer
def clear_buffer():
    global recv_buffer
    #self is the leader
    if role==3:
        #print(recv_buffer)
        for msg in recv_buffer:
            handle_recv(msg)
        recv_buffer=[]
    else:
        #print(recv_buffer)
        for msg in recv_buffer:
            redirect = {"src": my_id, "dst": msg['src'], "leader": leader_id, "type": "redirect", "MID": msg['MID']}
            send_msg(redirect)
            #print("redirect to: " + str(leader_id))
        recv_buffer = [] """

def do_get(key, mid):
    if key in store.keys():
        #print("get----------", key, store[key], mid)
        return {'type': 'ok', 'MID': mid, 'value': store[key]}
    else:
        return {'type': 'ok', 'value': '', 'MID': mid}
    
def broad_cast_rpc(key, value, client, mid):
    global store
    global log_entry
    global next_index
    log_entry
    if my_id==leader_id:
        #store[key]= value
        log_entry.append({'key': key, 'value':  value, 'term': current_term, 'client': client, 'MID': mid})
        # broadcase AppendEntries RPC to all followers
        resp = {'src':my_id, 'leader': my_id, 'type': 'append_entry_rpc', 'leader_commit': commit_idx}
        for k in next_index.keys():
           pli = next_index[k]-1
           resp['prelog_idx']=pli
           resp['prelog_term'] = log_entry[pli]['term']
           resp['entries']=log_entry[next_index[k]:]
           resp['dst']=k
           send_msg(resp)
    else:
        return
        


def handle_get_put(msg):
    msg_type = msg['type']
    #self is the leader
    if leader_id == my_id:
        if msg_type == 'get':
            #print("get---"+msg['dst']+" "+leader_id)
            resp = do_get(msg['key'], msg['MID'])
            resp['src']=my_id
            resp['dst']=msg['src']
            resp['leader']=leader_id
            send_msg(resp)
        elif msg_type == 'put':
            #print("put------------------", msg)
            broad_cast_rpc(msg['key'], msg['value'], msg['src'], msg['MID'])
    else:
        resp = msg
        resp['dst']=resp['src']
        resp['src']=my_id
        resp['type']='redirect'
        resp['leader']=leader_id
        #print("redirect to: "+str(leader_id) + msg_type)
        send_msg(resp)

def handle_getvote(msg):
    global voted
    global current_term
    global leader_id
    global role
    global voted

    if msg['src'] == my_id:
        return
    
    if msg['term'] > current_term and msg['lastLogIndex'] < len(log_entry)-1:
       print("here------")
       if leader_id == my_id:
           print("I am leader")
       leader_id='FFFF'
       role=1
       current_term = msg['term']
              
    if not voted and msg['term'] >= current_term and leader_id=='FFFF' and msg['lastLogIndex'] >= len(log_entry)-1:
       print("vote----------\n"+my_id+" "+msg['src'])
       resp = {'src': my_id, 'dst': msg['src'], 'type': 'send_vote', 'leader': 'FFFF'}
       send_msg(resp)
       voted = True 

def handle_sendvote(msg):
    global vote_received
    global next_index
    global leader_id
    
    if leader_id=='FFFF':
       vote_received += 1
       if(vote_received == 3):
          #print("send announce leader------\n" + my_id)
          for i in replicas:
             next_index[i] = commit_idx +1
             match_index[i] = -1
          leader_id = my_id
          role = 3
          send_msg({'src': my_id, 'dst': 'FFFF','type': 'announce_leader', 'term': current_term, 'leader': my_id})

def commit_state_machine():
    global commit_idx
    global last_applied
    global store 
    #print("commit_state_machine")
    #print(last_applied)
    #print(commit_idx)
    while(last_applied < commit_idx):
      entry = log_entry[last_applied+1]
      last_applied +=1
      store[entry['key']]=entry['value']
       

def handle_heartbeat(msg):
    global commit_idx
    global last_action_time
    if leader_id != msg['leader']:
        return
    
    last_action_time = time.time()
    if msg['commit_idx'] > commit_idx:
       commit_idx = min(msg['commit_idx'], len(log_entry)-1)
    commit_state_machine()
    last_action_time = time.time()

#msg:  {'src':my_id, 'leader': my_id, 'type': 'append_entry_rpc', 'leader_commit': commit_idx, 'prelog_idx', 'prelog_term', 'entries'}
#resp: {'src': , 'dst', 'leader', 'success':}
def handle_appendentry_rpc(msg):
   global log_entry
   #self is a leader 
   if my_id==leader_id:
      return
   else:
      if(len(log_entry)-1 < msg['prelog_idx']):
         resp = {'type': 'check_term', 'src': my_id, 'dst': leader_id, 'leader': leader_id}
         send_msg(resp)
      elif msg['prelog_idx']<0:
         log_entry = msg['entries']
         resp = {'type': 'put_success', 'src': my_id, 'dst': leader_id, 'leader': leader_id, 'next_idx': len(log_entry)}
         send_msg(resp)
      else:
         term = log_entry[msg['prelog_idx']]['term']
         if term != msg['prelog_term']:
             resp = {'type': 'check_term', 'src': my_id, 'dst': leader_id, 'leader': leader_id}
             send_msg(resp)
         else:
             idx = msg['prelog_idx']+1
             #print("idx:----------", idx)
             prev_entry = log_entry[0:idx]
             #print("-----------------------prev entry", prev_entry)
             log_entry = prev_entry + msg['entries']
             resp = {'type': 'put_success', 'src': my_id, 'dst': leader_id, 'leader': leader_id, 'next_idx': len(log_entry)}
             send_msg(resp)

def handle_check_term(msg):
    global log_entry
    global next_index
    next_index[msg['src']] -= 1
    if my_id==leader_id:
       prelog_idx = next_index[msg['src']]-1
       prelog_term = log_entry[prelog_idx]['term']
       entries = log_entry[next_index[msg['src']]:]
       resp = {'src':my_id, 'dst': msg['src'],'leader': my_id, 'type': 'append_entry_rpc', 'leader_commit': commit_idx, 'prelog_idx':prelog_idx, 'prelog_term': prelog_term, 'entries': entries}
       send_msg(resp)
    else:
        return

def handle_put_success(msg):
    global next_index
    global match_index
    global commit_idx
    global last_applied

    if msg["leader"] != my_id:
        return
    
    src = msg['src']
    next_index[src]=msg['next_idx']
    #print("previous match idx: ", match_index)
    match_index[src]=msg['next_idx']-1
    #print("match idx: ", match_index)
    values = match_index.values()
    values.sort()
    new_commit_idx = 1;
    try:
      new_commit_idx = values[2]
    except:
      print(values)
    #new_commit_idx = values.sort()[2]
    if new_commit_idx < 0:
       return
    for i in range(last_applied+1, new_commit_idx + 1):
        target = log_entry[i]
        resp = {'src': my_id, 'dst': target['client'], 'leader': leader_id, 'type': 'ok', 'MID': target['MID']}
        #print("put-------------\n", resp)
        send_msg(resp)
    commit_idx = new_commit_idx
    commit_state_machine() 
       
      

def handle_recv(msg):
    global current_term
    global voted
    global last_action_time
    global vote_received
    global leader_id
    global role
    global store
    #global recv_buffer
    msg_type = msg['type']
    if (msg_type == 'get' or msg_type=='put'):
        handle_get_put(msg)
    elif msg_type == 'get_vote':
        handle_getvote(msg)    
    #received hearbeat from leader
    elif msg_type == 'heartbeat_rpc' and not role==3:
         handle_heartbeat(msg)
        #received a vote from others
    elif msg_type == 'send_vote':
        handle_sendvote(msg) 
    elif msg_type == 'append_entry_rpc':
        handle_appendentry_rpc(msg)
    elif msg_type == 'check_term': 
        handle_check_term(msg)
    elif msg_type == 'put_success':
        handle_put_success(msg)
    elif msg_type == 'announce_leader' and leader_id=='FFFF':
        voted = False
        print("received announce_leader")
        current_term = msg['term']
        vote_received = 1
        leader_id = msg['leader']
        if leader_id==my_id:
           role = 3
        else:
           role = 1
        reset_timeouts()
        #print(recv_buffer)
        #clear_buffer()


last_action_time = time.time()
while True:
    #print("current leader: =" + str(leader_id))

    ready = select.select([sock], [], [], 0.1)[0]
    if sock in ready:
        msg_raw = sock.recv(32768)
        if len(msg_raw) == 0: continue
        msg = json.loads(msg_raw)
        #if leader is lost or has not been elected, add the msg to a buffer
        if leader_id=='FFFF' and (msg['type']=='put' or msg['type']=='get'):
            msg = {"src": my_id, "dst": msg['src'], "leader": 'FFFF', "type": "redirect", "MID": msg['MID']}
            send_msg(msg)
            #recv_buffer.append(msg)
        else:
            #clear_buffer()
            handle_recv(msg)
        
    #end of receiving msgs---------
    clock = time.time()
    time_passed = clock - last_action_time
    #send a heartbeat if self is the leader
    if time_passed > heartbeat_interval and my_id==leader_id:
        #print(my_id)
        msg = {'src': my_id, 'dst': 'FFFF', 'leader': leader_id, 'type': 'heartbeat_rpc', 'commit_idx': commit_idx}
        send_msg(msg)
        last_action_time = time.time()
    #become a candidate after candidate timeout
    elif time_passed > candidate_timeout and role == 2:
        role = 1
        voted = False
        vote_received = 1
        reset_timeouts()
    elif time_passed > candidate_timeout and role == 1:
        print("time_passed: "+str(time_passed)+ " " + str(candidate_timeout))
        leader_id='FFFF'
        role = 2
        getVote()
        reset_timeouts()
        
        
        
        
        
        
        
        
        
        
        
        
        
